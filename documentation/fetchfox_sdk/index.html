<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.0">
<title>fetchfox_sdk API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>fetchfox_sdk</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fetchfox_sdk.client" href="client.html">fetchfox_sdk.client</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fetchfox_sdk.workflow" href="workflow.html">fetchfox_sdk.workflow</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fetchfox_sdk.FetchFoxSDK"><code class="flex name class">
<span>class <span class="ident">FetchFoxSDK</span></span>
<span>(</span><span>api_key: Optional[str] = None, host: str = 'https://fetchfox.ai')</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the FetchFox SDK.</p>
<p>You may also provide an API key in the environment variable <code>FETCHFOX_API_KEY</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api_key</code></strong></dt>
<dd>Your FetchFox API key.
Overrides the environment variable.</dd>
<dt><strong><code>host</code></strong></dt>
<dd>API host URL (defaults to production)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FetchFoxSDK:
    def __init__(self, api_key: Optional[str] = None, host: str = &#34;https://fetchfox.ai&#34;):
        &#34;&#34;&#34;Initialize the FetchFox SDK.

        You may also provide an API key in the environment variable `FETCHFOX_API_KEY`.

        Args:
            api_key: Your FetchFox API key.  Overrides the environment variable.
            host: API host URL (defaults to production)
        &#34;&#34;&#34;
        self.base_url = urljoin(host, _API_PREFIX)

        self.api_key = api_key
        if self.api_key is None:
            self.api_key = os.environ.get(&#34;FETCHFOX_API_KEY&#34;)

        if not self.api_key:
            raise ValueError(
                &#34;API key must be provided either as argument or &#34;
                &#34;in FETCHFOX_API_KEY environment variable&#34;)

        self.headers = {
            &#39;Content-Type&#39;: &#39;application/json&#39;,
            &#39;Authorization&#39;: f&#39;Bearer: {self.api_key}&#39;
        }

    def _request(self, method: str, path: str, json_data: Optional[dict] = None,
                    params: Optional[dict] = None) -&gt; dict:
        &#34;&#34;&#34;Make an API request.

        Args:
            method: HTTP method
            path: API path
            json_data: Optional JSON body
            params: Optional query string parameters
        &#34;&#34;&#34;
        url = urljoin(self.base_url, path)

        response = requests.request(
            method,
            url,
            headers=self.headers,
            json=json_data,
            params=params
        )

        response.raise_for_status()
        body = response.json()

        logger.debug(f&#34;Response from %s %s:\n%s&#34;, method, path, pformat(body))
        return body

    def register_workflow(self, workflow: Workflow) -&gt; str:
        &#34;&#34;&#34;Create a new workflow.

        Args:
            workflow: Workflow object

        Returns:
            Workflow ID
        &#34;&#34;&#34;
        response = self._request(&#39;POST&#39;, &#39;workflows&#39;, workflow.to_dict())

        # NOTE: If we need to return anything else here, we should keep this
        # default behavior, but add an optional kwarg so &#34;full_response=True&#34;
        # can be supplied, and then we return everything
        return response[&#39;id&#39;]

    def get_workflows(self) -&gt; list:
        &#34;&#34;&#34;Get workflows

        Returns:
            List of workflows
        &#34;&#34;&#34;
        response = self._request(&#34;GET&#34;, &#34;workflows&#34;)

        # NOTE: Should we return Workflow objects intead?
        return response[&#39;results&#39;]

    def run_workflow(self, workflow_id: Optional[str] = None,
                    workflow: Optional[Workflow] = None,
                    params: Optional[dict] = None) -&gt; str:
        &#34;&#34;&#34;Run a workflow. Either provide the ID of a registered workflow,
        or provide a workflow object (which will be registered
        automatically, for convenience).

        You can browse https://fetchfox.ai to find publicly available workflows
        authored by others.  Copy the workflow ID and use it here.  Often,
        in this case, you will also want to provide parameters.

        Args:
            workflow_id: ID of an existing workflow to run
            workflow: A Workflow object to register and run
            params: Optional parameters for the workflow

        Returns:
            Job ID

        Raises:
            ValueError: If neither workflow_id nor workflow is provided
        &#34;&#34;&#34;
        if workflow_id is None and workflow is None:
            raise ValueError(
                &#34;Either workflow_id or workflow must be provided&#34;)

        if workflow_id is not None and workflow is not None:
            raise ValueError(
                &#34;Provide only a workflow or a workflow_id, not both.&#34;)

        if workflow and not isinstance(workflow, Workflow):
            raise ValueError(
                &#34;The workflow argument must be a fetchfox_sdk.Workflow&#34;)
        if workflow_id and not isinstance(workflow_id, str):
            raise ValueError(
                &#34;The workflow_id argument must be a string &#34;
                &#34;representing a registered workflow&#39;s ID&#34;)

        if params is not None:
            raise NotImplementedError(&#34;Cannot pass params to workflows yet&#34;)
            # TODO:
            #   It sounds like these might be passed in the const/init step?
            #   Or, maybe they need to go in as a dictionary on the side?
            # TODO:
            #   https://docs.google.com/document/d/17ieru_HfU3jXBilcZqL1Ksf27rsVPvOIQ8uxmHi2aeE/edit?disco=AAABdjyFjgw
            #   allow list-expansion here like above, pretty cool

        if workflow_id is None:
            workflow_id = self.register_workflow(workflow) # type: ignore
            logger.info(&#34;Registered new workflow with id: %s&#34;, workflow_id)

        #response = self._request(&#39;POST&#39;, f&#39;workflows/{workflow_id}/run&#39;, params or {})
        response = self._request(&#39;POST&#39;, f&#39;workflows/{workflow_id}/run&#39;)

        # NOTE: If we need to return anything else here, we should keep this
        # default behavior, but add an optional kwarg so &#34;full_response=True&#34;
        # can be supplied, and then we return everything
        return response[&#39;jobId&#39;]

    def get_job_status(self, job_id: str) -&gt; dict:
        &#34;&#34;&#34;Get the status and results of a job.  Returns partial results before
        eventually returning the full results.

        When job_status[&#39;done&#39;] == True, the full results are present in
        response[&#39;results&#39;][&#39;items&#39;].

        If you want to manage your own polling, you can use this instead of
        await_job_completion()

        NOTE: Jobs are not created immediately after you call run_workflow().
        The status will not be available until the job is scheduled, so this
        will 404 initially.
        &#34;&#34;&#34;
        return self._request(&#39;GET&#39;, f&#39;jobs/{job_id}&#39;)

    def await_job_completion(self, job_id: str, poll_interval: float = 5.0,
            full_response: bool = False, keep_urls: bool = False):
        &#34;&#34;&#34;Wait for a job to complete and return the resulting items or full
        response.

        Use &#34;get_job_status()&#34; if you want to manage polling yourself.

        Args:
            job_id: the id of the job, as returned by run_workflow()
            poll_interval: in seconds
            full_response: defaults to False, so we return the result_items only.  Pass full_response=True if you want to access the entire body of the final response.
            keep_urls: defaults to False so result items match the given item template.  Set to true to include the &#34;_url&#34; property.  Not necessary if _url is the ONLY key.
        &#34;&#34;&#34;

        MAX_WAIT_FOR_JOB_ALIVE_MINUTES = 5 #TODO: reasonable?
        started_waiting_for_job_dt = None

        while True:

            try:
                status = self.get_job_status(job_id)

            except requests.exceptions.HTTPError as e:
                if e.response.status_code == 404:

                    logger.info(&#34;Waiting for job %s to be scheduled.&#34;, job_id)

                    if started_waiting_for_job_dt is None:
                        started_waiting_for_job_dt = datetime.now()
                    else:
                        waited = datetime.now() - started_waiting_for_job_dt
                        if waited &gt; timedelta(minutes=MAX_WAIT_FOR_JOB_ALIVE_MINUTES):
                            raise RuntimeError(
                                f&#34;Job {job_id} is taking unusually long to schedule.&#34;)

                    status = {}

                else:
                    raise

            if status.get(&#39;done&#39;):
                if full_response:
                    return status

                # Otherwise, process the status into result items that match
                # the item_template (optionally retaining _url for find_urls())
                try:
                    full_items = status[&#39;results&#39;][&#39;items&#39;]
                except KeyError:
                    print(&#34;No results.&#34;)
                    return None

                stripped_items = []
                for item in full_items:
                    # First get just the non-underscore keys
                    filtered_item = {
                        k: v
                        for k, v
                        in item.items()
                        if not k.startswith(&#39;_&#39;)
                    }

                    # Keep _url if explicitly requested OR if we have no other keys
                    if (keep_urls or not filtered_item) and &#39;_url&#39; in item:
                        filtered_item[&#39;_url&#39;] = item[&#39;_url&#39;]

                    stripped_items.append(filtered_item)

                return stripped_items

            time.sleep(poll_interval)

    def _plan_extraction_from_url_and_prompt(self,
            url: str, instruction: str) -&gt; Workflow:

        fetch_response = self._request(&#39;GET&#39;, &#39;fetch&#39;, params={&#39;url&#39;: url})
        html_url = fetch_response[&#39;html&#39;]

        plan_response = self._request(&#39;POST&#39;, &#39;plan/from-prompt&#39;, {
            &#34;prompt&#34;: instruction,
            &#34;urls&#34;: [url],
            &#34;html&#34;: html_url
        })

        return Workflow.from_dict(plan_response)


    def extract(self, url: str, instruction: Optional[str] = None,
                item_template: Optional[Dict[str, str]] = None,
                single=False, max_pages=1, limit=None) -&gt; List[Dict]:
        &#34;&#34;&#34;Extract items from a given URL, given either a prompt or a template.

        An instructional prompt is just natural language instruction describing
        the desired results.

        The options &#34;single&#34;, &#34;max_pages&#34;, and &#34;limit&#34; may NOT be given with
        &#34;instruction&#34;. These options may only be provided with an item template.

        An item template is a dictionary where the keys are the desired
        output fieldnames and the values are the instructions for extraction of
        that field.

        Example item template:
        {
            &#34;magnitude&#34;: &#34;What is the magnitude of this earthquake?&#34;,
            &#34;location&#34;: &#34;What is the location of this earthquake?&#34;,
            &#34;time&#34;: &#34;What is the time of this earthquake?&#34;
        }

        To follow pagination, provide max_pages &gt; 1.

        Args:
            instruction: an instructional prompt as described above
            item_template: the item template described above
            single: Defaults to False. Set this to True if each URL has only a single item to extract.
            max_pages: enable pagination from the given URL.  Defaults to one page only.
            limit: limit the number of items yielded by this step
        &#34;&#34;&#34;

        if item_template and instruction:
            raise ValueError(
                &#34;Please provide either an item_template or a prompt, but not both.&#34;)
        if item_template is None and instruction is None:
            raise ValueError(&#34;Please provide an item_template or prompt.&#34;)

        implied_workflow = Workflow().init(url)

        if item_template:
            implied_workflow.extract(
                item_template,
                single=single,
                max_pages=max_pages,
                limit=limit
            )
        else:
            # if these options are set to anything other than their defaults,
            # warn, because they are not being respected.
            # We could also throw an error here.

            if single:
                print(&#34;Warning: &#39;single&#39; will be ignored in instruction mode.&#34;)
            if max_pages != 1:
                print(&#34;Warning: &#39;max_pages&#39; will be ignored in instruction mode.&#34;)
            if limit is not None:
                print(&#34;Warning: &#39;limit&#39; will be ignored in instruction mode.&#34;)

            implied_workflow = \
                self._plan_extraction_from_url_and_prompt(
                    url,
                    instruction)

        job_id = self.run_workflow(workflow=implied_workflow)
        # The workflow will be registered and run, but in this convenience
        # function, the user doesn&#39;t care about that.

        result_items = self.await_job_completion(job_id)
        return result_items

    def find_urls(self, url: str, instruction: str, max_pages: int = 1,
            limit=None) -&gt; List[str]:
        &#34;&#34;&#34;Find URLs on a webpage using AI, given an instructional prompt.

         An instructional prompt is just natural language instruction describing
        the desired results.

        Example Instructional Prompts:
            &#34;Find me all the links to bicycles that are not electric &#39;e-bikes&#39;&#34;
            &#34;Find me the links to each product detail page.&#34;
            &#34;Find me the links for each US State&#34;
            &#34;Find me the links to the profiles for employees among the C-Suite&#34;

        Args:
            instruction: an instructional prompt as described above
            max_pages: provide an integer &gt; 1 if you want to follow pagination
            limit: limits the number of items yielded by this step
        &#34;&#34;&#34;
        implied_workflow = (
            Workflow()
            .init(url)
            .find_urls(instruction, max_pages=max_pages, limit=limit)
        )

        job_id = self.run_workflow(workflow=implied_workflow)
        urls_as_items = self.await_job_completion(job_id, keep_urls=True)
        return [ item[&#39;_url&#39;] for item in urls_as_items ]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fetchfox_sdk.FetchFoxSDK.await_job_completion"><code class="name flex">
<span>def <span class="ident">await_job_completion</span></span>(<span>self, job_id: str, poll_interval: float = 5.0, full_response: bool = False, keep_urls: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for a job to complete and return the resulting items or full
response.</p>
<p>Use "get_job_status()" if you want to manage polling yourself.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>job_id</code></strong></dt>
<dd>the id of the job, as returned by run_workflow()</dd>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>in seconds</dd>
<dt><strong><code>full_response</code></strong></dt>
<dd>defaults to False, so we return the result_items only.
Pass full_response=True if you want to access the entire body of the final response.</dd>
<dt><strong><code>keep_urls</code></strong></dt>
<dd>defaults to False so result items match the given item template.
Set to true to include the "_url" property.
Not necessary if _url is the ONLY key.</dd>
</dl></div>
</dd>
<dt id="fetchfox_sdk.FetchFoxSDK.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, url: str, instruction: Optional[str] = None, item_template: Optional[Dict[str, str]] = None, single=False, max_pages=1, limit=None) ‑> List[Dict[~KT, ~VT]]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract items from a given URL, given either a prompt or a template.</p>
<p>An instructional prompt is just natural language instruction describing
the desired results.</p>
<p>The options "single", "max_pages", and "limit" may NOT be given with
"instruction". These options may only be provided with an item template.</p>
<p>An item template is a dictionary where the keys are the desired
output fieldnames and the values are the instructions for extraction of
that field.</p>
<p>Example item template:
{
"magnitude": "What is the magnitude of this earthquake?",
"location": "What is the location of this earthquake?",
"time": "What is the time of this earthquake?"
}</p>
<p>To follow pagination, provide max_pages &gt; 1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instruction</code></strong></dt>
<dd>an instructional prompt as described above</dd>
<dt><strong><code>item_template</code></strong></dt>
<dd>the item template described above</dd>
<dt><strong><code>single</code></strong></dt>
<dd>Defaults to False. Set this to True if each URL has only a single item to extract.</dd>
<dt><strong><code>max_pages</code></strong></dt>
<dd>enable pagination from the given URL.
Defaults to one page only.</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>limit the number of items yielded by this step</dd>
</dl></div>
</dd>
<dt id="fetchfox_sdk.FetchFoxSDK.find_urls"><code class="name flex">
<span>def <span class="ident">find_urls</span></span>(<span>self, url: str, instruction: str, max_pages: int = 1, limit=None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Find URLs on a webpage using AI, given an instructional prompt.</p>
<p>An instructional prompt is just natural language instruction describing
the desired results.</p>
<p>Example Instructional Prompts:
"Find me all the links to bicycles that are not electric 'e-bikes'"
"Find me the links to each product detail page."
"Find me the links for each US State"
"Find me the links to the profiles for employees among the C-Suite"</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instruction</code></strong></dt>
<dd>an instructional prompt as described above</dd>
<dt><strong><code>max_pages</code></strong></dt>
<dd>provide an integer &gt; 1 if you want to follow pagination</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>limits the number of items yielded by this step</dd>
</dl></div>
</dd>
<dt id="fetchfox_sdk.FetchFoxSDK.get_job_status"><code class="name flex">
<span>def <span class="ident">get_job_status</span></span>(<span>self, job_id: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get the status and results of a job.
Returns partial results before
eventually returning the full results.</p>
<p>When job_status['done'] == True, the full results are present in
response['results']['items'].</p>
<p>If you want to manage your own polling, you can use this instead of
await_job_completion()</p>
<p>NOTE: Jobs are not created immediately after you call run_workflow().
The status will not be available until the job is scheduled, so this
will 404 initially.</p></div>
</dd>
<dt id="fetchfox_sdk.FetchFoxSDK.get_workflows"><code class="name flex">
<span>def <span class="ident">get_workflows</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Get workflows</p>
<h2 id="returns">Returns</h2>
<p>List of workflows</p></div>
</dd>
<dt id="fetchfox_sdk.FetchFoxSDK.register_workflow"><code class="name flex">
<span>def <span class="ident">register_workflow</span></span>(<span>self, workflow: <a title="fetchfox_sdk.workflow.Workflow" href="workflow.html#fetchfox_sdk.workflow.Workflow">Workflow</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new workflow.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>workflow</code></strong></dt>
<dd>Workflow object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Workflow ID</p></div>
</dd>
<dt id="fetchfox_sdk.FetchFoxSDK.run_workflow"><code class="name flex">
<span>def <span class="ident">run_workflow</span></span>(<span>self, workflow_id: Optional[str] = None, workflow: Optional[<a title="fetchfox_sdk.workflow.Workflow" href="workflow.html#fetchfox_sdk.workflow.Workflow">Workflow</a>] = None, params: Optional[dict] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Run a workflow. Either provide the ID of a registered workflow,
or provide a workflow object (which will be registered
automatically, for convenience).</p>
<p>You can browse <a href="https://fetchfox.ai">https://fetchfox.ai</a> to find publicly available workflows
authored by others.
Copy the workflow ID and use it here.
Often,
in this case, you will also want to provide parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>workflow_id</code></strong></dt>
<dd>ID of an existing workflow to run</dd>
<dt><strong><code>workflow</code></strong></dt>
<dd>A Workflow object to register and run</dd>
<dt><strong><code>params</code></strong></dt>
<dd>Optional parameters for the workflow</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Job ID</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If neither workflow_id nor workflow is provided</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="fetchfox_sdk.Workflow"><code class="flex name class">
<span>class <span class="ident">Workflow</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Workflow:
    @classmethod
    def from_json(cls, json_str: str) -&gt; &#34;Workflow&#34;:
        &#34;&#34;&#34;Create a workflow from a JSON string.&#34;&#34;&#34;
        workflow_dict = json.loads(json_str)
        workflow = cls()
        workflow._workflow = workflow_dict
        return workflow

    @classmethod
    def from_dict(cls, workflow_dict: dict) -&gt; &#34;Workflow&#34;:
        &#34;&#34;&#34;Create a workflow from a dictionary.&#34;&#34;&#34;
        workflow = cls()
        workflow._workflow = workflow_dict
        #TODO: We could actually implement validation in __init__
        #TODO: maybe this should not be here at all, might confuse.
        return workflow

    def __init__(self):
        self._workflow = {
            &#34;steps&#34;: [],
            &#34;options&#34;: {}
        }

    def init(self, url: str) -&gt; &#34;Workflow&#34;:

        #TODO: Do we need to allow other data here?

        self._workflow[&#34;steps&#34;].append({
            &#34;name&#34;: &#34;const&#34;,
            &#34;args&#34;: {
                &#34;items&#34;: [{&#34;url&#34;: url}],
                &#34;maxPages&#34;: 1 #TODO
            }
        })
        return self

    def extract(self, item_template: dict, single=None,
            limit=None, max_pages=1) -&gt; &#34;Workflow&#34;:
        &#34;&#34;&#34;Provide an item_template which describes what you want to extract
        from the URLs processed by this step.

        The keys of this template are the fieldnames,
        and the values are the instructions for extracting that field.

        Example:
        {
            &#34;magnitude&#34;: &#34;What is the magnitude of this earthquake?&#34;,
            &#34;location&#34;: &#34;What is the location of this earthquake?&#34;,
            &#34;time&#34;: &#34;What is the time of this earthquake?&#34;
        }

        Args:
            item_template: the item template described above
            single: set this to True if each URL has only a single item.
                    Set this to False if each URL should yield multiple items
            max_pages: enable pagination from the given URL.  Defaults to one page only.
            limit: limit the number of items yielded by this step
        &#34;&#34;&#34;

        #TODO: call it &#34;multiple&#34; and default to false?  semantically clearer?
        #TODO: view: selecthtml / textonly

        if single is None:
            single = True
            print(
                &#34;Extracting only a single item per page in this workflow.  &#34;
                &#34;Pass `single=False` to extract multiple result items per page&#34;)

        self._workflow[&#34;steps&#34;].append({
            &#34;name&#34;: &#34;extract&#34;,
            &#34;args&#34;: {
                &#34;questions&#34;: item_template,
                &#34;single&#34;: single,
                &#34;maxPages&#34;: max_pages,
                &#34;limit&#34;: limit
            }
        })
        return self

    def find_urls(self, instruction: str, max_pages=1, limit=None) -&gt; &#34;Workflow&#34;:
        &#34;&#34;&#34;Provide instructions which describe how to find the URLs
        you want to extract from the page.

        Example: &#34;Find me all of the links to the detail pages for individual
        earthquakes.&#34;

        Args:
            instruction: the instruction described above
            max_pages: enable pagination from the given URL.  Defaults to one page only.
            limit: limit the number of items yielded by this step
        &#34;&#34;&#34;
        self._workflow[&#34;steps&#34;].append({
            &#34;name&#34;: &#34;crawl&#34;,
            &#34;args&#34;: {
                &#34;query&#34;: instruction,
                &#34;maxPages&#34;: max_pages,
                &#34;limit&#34;: limit
            }
        })
        return self

    def limit(self, n: int) -&gt; &#34;Workflow&#34;:
        if self._workflow[&#39;options&#39;].get(&#39;limit&#39;) is not None:
            raise ValueError(
                &#34;This limit is per-workflow, and may only be set once.&#34;)

        self._workflow[&#39;options&#39;][&#34;limit&#34;] = n
        return self

    #TODO: `transform()` as the underlying operation for extract AND findUrls
    #TODO: crawl

    def unique(self, fields_list: List[str], limit=None) -&gt; &#34;Workflow&#34;:
        &#34;&#34;&#34;Provide a list of fields which will be used to check the uniqueness
        of the items passing through this step.

        Any items which are duplicates (as determined by these fields only),
        will be filtered and will not be seen by the next step in your workflow.

        Args:
            fields_list: the instruction described above
            limit: limit the number of items yielded by this step
        &#34;&#34;&#34;

        self._workflow[&#39;steps&#39;].append({
            &#34;name&#34;: &#34;unique&#34;,
            &#34;args&#34;: {
                &#34;fields&#34;: fields_list,
                &#34;limit&#34;: limit
            }
        })

        return self

    def filter(self, instruction: str, limit=None) -&gt; &#34;Workflow&#34;:
        &#34;&#34;&#34;Provide instructions for how to filter items.

        Example: &#34;Exclude any earthquakes that were unlikely to cause significant property damage.&#34;

        Args:
            instruction: the instruction described above
            limit: limit the number of items yielded by this step
        &#34;&#34;&#34;

        self._workflow[&#39;steps&#39;].append({
            &#34;name&#34;: &#34;filter&#34;,
            &#34;args&#34;: {
                &#34;query&#34;: instruction,
                &#34;limit&#34;: limit
            }
        })

        return self

    def to_dict(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Convert workflow to dictionary format.&#34;&#34;&#34;
        return self._workflow

    def to_json(self):
        return json.dumps(self)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="fetchfox_sdk.Workflow.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>workflow_dict: dict) ‑> <a title="fetchfox_sdk.workflow.Workflow" href="workflow.html#fetchfox_sdk.workflow.Workflow">Workflow</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a workflow from a dictionary.</p></div>
</dd>
<dt id="fetchfox_sdk.Workflow.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>json_str: str) ‑> <a title="fetchfox_sdk.workflow.Workflow" href="workflow.html#fetchfox_sdk.workflow.Workflow">Workflow</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a workflow from a JSON string.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fetchfox_sdk.Workflow.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, item_template: dict, single=None, limit=None, max_pages=1) ‑> <a title="fetchfox_sdk.workflow.Workflow" href="workflow.html#fetchfox_sdk.workflow.Workflow">Workflow</a></span>
</code></dt>
<dd>
<div class="desc"><p>Provide an item_template which describes what you want to extract
from the URLs processed by this step.</p>
<p>The keys of this template are the fieldnames,
and the values are the instructions for extracting that field.</p>
<p>Example:
{
"magnitude": "What is the magnitude of this earthquake?",
"location": "What is the location of this earthquake?",
"time": "What is the time of this earthquake?"
}</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item_template</code></strong></dt>
<dd>the item template described above</dd>
<dt><strong><code>single</code></strong></dt>
<dd>set this to True if each URL has only a single item.
Set this to False if each URL should yield multiple items</dd>
<dt><strong><code>max_pages</code></strong></dt>
<dd>enable pagination from the given URL.
Defaults to one page only.</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>limit the number of items yielded by this step</dd>
</dl></div>
</dd>
<dt id="fetchfox_sdk.Workflow.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, instruction: str, limit=None) ‑> <a title="fetchfox_sdk.workflow.Workflow" href="workflow.html#fetchfox_sdk.workflow.Workflow">Workflow</a></span>
</code></dt>
<dd>
<div class="desc"><p>Provide instructions for how to filter items.</p>
<p>Example: "Exclude any earthquakes that were unlikely to cause significant property damage."</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instruction</code></strong></dt>
<dd>the instruction described above</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>limit the number of items yielded by this step</dd>
</dl></div>
</dd>
<dt id="fetchfox_sdk.Workflow.find_urls"><code class="name flex">
<span>def <span class="ident">find_urls</span></span>(<span>self, instruction: str, max_pages=1, limit=None) ‑> <a title="fetchfox_sdk.workflow.Workflow" href="workflow.html#fetchfox_sdk.workflow.Workflow">Workflow</a></span>
</code></dt>
<dd>
<div class="desc"><p>Provide instructions which describe how to find the URLs
you want to extract from the page.</p>
<p>Example: "Find me all of the links to the detail pages for individual
earthquakes."</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instruction</code></strong></dt>
<dd>the instruction described above</dd>
<dt><strong><code>max_pages</code></strong></dt>
<dd>enable pagination from the given URL.
Defaults to one page only.</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>limit the number of items yielded by this step</dd>
</dl></div>
</dd>
<dt id="fetchfox_sdk.Workflow.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self, url: str) ‑> <a title="fetchfox_sdk.workflow.Workflow" href="workflow.html#fetchfox_sdk.workflow.Workflow">Workflow</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fetchfox_sdk.Workflow.limit"><code class="name flex">
<span>def <span class="ident">limit</span></span>(<span>self, n: int) ‑> <a title="fetchfox_sdk.workflow.Workflow" href="workflow.html#fetchfox_sdk.workflow.Workflow">Workflow</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fetchfox_sdk.Workflow.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert workflow to dictionary format.</p></div>
</dd>
<dt id="fetchfox_sdk.Workflow.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fetchfox_sdk.Workflow.unique"><code class="name flex">
<span>def <span class="ident">unique</span></span>(<span>self, fields_list: List[str], limit=None) ‑> <a title="fetchfox_sdk.workflow.Workflow" href="workflow.html#fetchfox_sdk.workflow.Workflow">Workflow</a></span>
</code></dt>
<dd>
<div class="desc"><p>Provide a list of fields which will be used to check the uniqueness
of the items passing through this step.</p>
<p>Any items which are duplicates (as determined by these fields only),
will be filtered and will not be seen by the next step in your workflow.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fields_list</code></strong></dt>
<dd>the instruction described above</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>limit the number of items yielded by this step</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fetchfox_sdk.client" href="client.html">fetchfox_sdk.client</a></code></li>
<li><code><a title="fetchfox_sdk.workflow" href="workflow.html">fetchfox_sdk.workflow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fetchfox_sdk.FetchFoxSDK" href="#fetchfox_sdk.FetchFoxSDK">FetchFoxSDK</a></code></h4>
<ul class="">
<li><code><a title="fetchfox_sdk.FetchFoxSDK.await_job_completion" href="#fetchfox_sdk.FetchFoxSDK.await_job_completion">await_job_completion</a></code></li>
<li><code><a title="fetchfox_sdk.FetchFoxSDK.extract" href="#fetchfox_sdk.FetchFoxSDK.extract">extract</a></code></li>
<li><code><a title="fetchfox_sdk.FetchFoxSDK.find_urls" href="#fetchfox_sdk.FetchFoxSDK.find_urls">find_urls</a></code></li>
<li><code><a title="fetchfox_sdk.FetchFoxSDK.get_job_status" href="#fetchfox_sdk.FetchFoxSDK.get_job_status">get_job_status</a></code></li>
<li><code><a title="fetchfox_sdk.FetchFoxSDK.get_workflows" href="#fetchfox_sdk.FetchFoxSDK.get_workflows">get_workflows</a></code></li>
<li><code><a title="fetchfox_sdk.FetchFoxSDK.register_workflow" href="#fetchfox_sdk.FetchFoxSDK.register_workflow">register_workflow</a></code></li>
<li><code><a title="fetchfox_sdk.FetchFoxSDK.run_workflow" href="#fetchfox_sdk.FetchFoxSDK.run_workflow">run_workflow</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fetchfox_sdk.Workflow" href="#fetchfox_sdk.Workflow">Workflow</a></code></h4>
<ul class="two-column">
<li><code><a title="fetchfox_sdk.Workflow.extract" href="#fetchfox_sdk.Workflow.extract">extract</a></code></li>
<li><code><a title="fetchfox_sdk.Workflow.filter" href="#fetchfox_sdk.Workflow.filter">filter</a></code></li>
<li><code><a title="fetchfox_sdk.Workflow.find_urls" href="#fetchfox_sdk.Workflow.find_urls">find_urls</a></code></li>
<li><code><a title="fetchfox_sdk.Workflow.from_dict" href="#fetchfox_sdk.Workflow.from_dict">from_dict</a></code></li>
<li><code><a title="fetchfox_sdk.Workflow.from_json" href="#fetchfox_sdk.Workflow.from_json">from_json</a></code></li>
<li><code><a title="fetchfox_sdk.Workflow.init" href="#fetchfox_sdk.Workflow.init">init</a></code></li>
<li><code><a title="fetchfox_sdk.Workflow.limit" href="#fetchfox_sdk.Workflow.limit">limit</a></code></li>
<li><code><a title="fetchfox_sdk.Workflow.to_dict" href="#fetchfox_sdk.Workflow.to_dict">to_dict</a></code></li>
<li><code><a title="fetchfox_sdk.Workflow.to_json" href="#fetchfox_sdk.Workflow.to_json">to_json</a></code></li>
<li><code><a title="fetchfox_sdk.Workflow.unique" href="#fetchfox_sdk.Workflow.unique">unique</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.0</a>.</p>
</footer>
</body>
</html>
